import javax.naming.spi.DirStateFactory.Result;

// сложность О(n) - т.к. поиск любой нодыы требует перебора эл-тов
// использование бинарного поиска не дает выгода, т.к. обращение по индексам с константной скоростью недоступно
// вставка в связанный список при наличии ссылки на нужную ноду O(1). Если ссылки нет, то перебирать эл-ты придется.    А в массив О(n)

public class Lec_3_1_list {
    Node head;  // ссылка на 1ю позицию для односвязного списка. Если двусвязн.список, то дол.быть на 1ю и последнюю
    Node tail;  // ссылка на последний эл-т в списке


    // функция вставки без привязки к ноде (без ссылки  к эл-ту)
    // вставка в конец двусвязанного списка (есть ссылки на предыд.и след.значение)
    public void add (int value) { 
        Node node = new Node();  // создаем новую ноду
        node.value = value;  // заполним ее
        if (head == null) {  // проверяем, есть ли эл-ты в списке или это 1й эл-т в ноде
            head = node;
            tail = node; // запоняем сразу и голову и хвост в пустом списке => делаем ссылку сразу на head и tail
        } else {
            tail.next = node; // берем текущий tail, говорим, что его следующая нода равна нашей ноде
            node.previous = tail; // наша нода начинает сылаться на текущий tail
            tail = node;  // обновляем tail значением нашей ноды
        }
    }


    // функция вставки эл-та в середину списка после Node node  - O(1)
    public void add (int value, Node node) {
        Node next = node.next;  // ссылка на Ноду некст, то, на что ссылается текущая нода
        Node newNode = new Node();  // создаем новую ноду
        newNode.value = value;  // заполним ее
        node.next = newNode;  // берем текущую ноду и говорим, что ее новое значение это новая нода -newNode
        newNode.previous = node;  // для ньюНод говорим, что ее предыдущее значение - это на текущий момент нода
        if (next == null) {  // если у эл-та связан.списка нет крайнего объекта, значит его переменная должна лежать в tail
            tail = newNode;  // значит его переменная должна лежать в tail. Переназначаем tail
        } else {
            next.previous = newNode;
            newNode = next;
        }
    }


    // функция удаления эл-та типа Нода. До этого нашли его методом find
    public void delete (Node node) {
        Node previous = node.previous;  // создаем новые переменные
        Node next = node.next;   // создаем новые переменные
        if (previous == null) {  // если получили head ноду, т.е.первую
            next.previous = null;  // тогда берем следующую ноду и обнуляем ее значение, т.е. удаляем 1й эл-т списка
            head = next;  // началом списка будет следующий эл-т
        } else {
            if (next == null) {  // если эл-т находится в конце списка
                previous.next = null;
                tail = previous;
            } else {
                // рассматриваем, что эл-т не head и не tail, т.е. не 1й и не последний
                previous.next = next;  // previous.next теперь будет ссылаться на next
                next.previous = previous;  // а next.previous теперь будет ссылаться на previous
                // таким образом мы удалили информацию о нашей ноде из связанного списка
            }
        }
    }


    // поиск
    public Node find(int value) {
        Node currentNode = head; // переменная currentNode, к-я начинается с head
        while (currentNode != null) { // т.к. это не массив, то передаем не ндексы, а Ноды (узлы)
            if (currentNode.value == value) {
                return currentNode;
            }
            currentNode = currentNode.next;
        }
        return null; //  если не нашлось искомого эл-та
    }


    // разворот для двусвязанного списка
    public void revert() {
        Node currentNode = head;
        while (currentNode != null) {  // проходим по списку
            Node next = currentNode.next;  // используем ссылки на предыд. и след. ноду
            Node previous = currentNode.previous;
            currentNode.next = previous;  // меняем их местами
            currentNode.previous = next;
            if (previous == null) {  // добавляем обработку событий head и tail
                tail = currentNode;  // currentNode по умолчанию является head-ом, она должна стать tail-ом
            }
            if (next == null) {  // говорим о последнем эл-те
                head = currentNode; // должен стать первым эл-том
            }
            currentNode = next;  // каррентНод(текущий) становится следующим
        }
    }


    // // разворот для односвязанного списка - чаще работа со стеком
    // // у односвязанного списка ссылки на tail может не быть
    // // надо закоммитить вверху в Lec_3_1_list для односвязюсписка: Node tail;  // ссылка на последний эл-т в списке
    // // и внизу в Node закоммитить это: Node previous;  // поле previous, к-е будет описывать предыдущее значение для 2-связан.списка
    // // рекурсивный метод, т.к.
    // // делаем функцию приватной, т.к. не оч.красивая для пользовательского интерфейса. сделаем публичн.ф-ю без параметров - перегрузка
    // public void revert1 () {   // перегруженный метод. Ниже - основной
    //     if (head != null && head.next != null) { // список не устой и больше 2х эл-тов
    //         Node temp = head; // Временная нода, куда поместим head // head не обработан рекурсивно
    //         revert1(head.next, head);  // запускаем рекурсию со 2-го эл-та списка head.next => 1й эл-т не меняется
    //         temp.next = null;  // т.к.head не обработан рекурсивно, то для него следующ.значение дол.быть = null
    //         // если будет учет tail, то здесь надо будет учитывать обработку tail
    //         // т.е. помимо сброса значения (temp.next = null), надо будет сохранить последнюю ноду, т.е. сделать обмен head и tail
    //     }
    // }

    // // делаем функцию приватной, т.к. не оч.красивая для пользовательского интерфейса. сделаем публичн.ф-ю без параметров - перегрузка
    // private void revert1(Node currentNode, Node previousNode) { // принимаем ссылку на текущую ноду и на ноду, с которой пришли
    //     if (currentNode.next == null) {  // если дошли до конца списка
    //         head = currentNode; //  делаем последн.ноду началом списка
    //     } else {
    //         revert1(currentNode.next, currentNode);  // запускаем рекурсию, если эл-т не последний
    //     }
    //     currentNode.next = previousNode;  // замена ссылок - запустили обратное значение
    //     // previousNode.next = null; // переместили в перегруженный метод
    //     }
    // }



    // работа за константную скорость O(1) ?
    // СТЭК (принцип LIFO последний зашел - первый вышел) поэтому будем работать только с операциями head
    // проще всего делается на основе односвязанного списка.
    // поэтому надо закомментировать вверху в Lec_3_1_list для односвязюсписка: Node tail;  // ссылка на последний эл-т в списке
    // и внизу в Node закоммитить это: Node previous;  // поле previous, к-е будет описывать предыдущее значение для 2-связан.списка
    // для очереди напишем 2 метода: push(положить данные) и pop(извлечь данные)
    public void push(int value) {  // для СТЭКА. Добавит значение в начло нашего стэка (очереди)
        Node node = new Node();
        node.value = value;
        node.next = head; // нод.некст это текущий хеад
        head = node;  // а хеад - это нод. Т.о. добавляем наш эл-т в начало списка
    }

    // для очереди напишем 2 метода: push(положить данные) и pop(извлечь данные)
    // по умолчание извлекает последний эл-т стэка, т.е. к-й лежит на самом верху, в начале списка - head
    // для СТЭКА  // сделали Integer, а не int. Тогда сможет вернуть null, если очередь не пуста, ч.б. не кидать исключения
    public Integer pop() {  // не принимает аргумент, т.к. по умолч.извлекает последн.эл-т стека, к-й лежит в самом верху - head
        Integer result = null;
        if (head != null){
            result = head.value;  
            head = head.next; // head присваиваем занчение head.next. Если head.next null, то получим пустой стэк на будущее
        }
        return result;
    }

    // работа за константную скорость O(1)
    // для очереди необходим двусвязный список
    // для очереди Node tail и Node previous не комментруются
    public void push1(int value) {  // для ОЧЕРЕДИ. Эл-ты вставляются в начало очереди
        Node node = new Node();
        node.value = value;
        node.next = head;
        head.previous = node;
        head = node;
    }

    // работа за константную скорость O(1)
    // вместо метода pop для очереди используется метод peek. Позволяет извлечь последний эл-т очереди. (метод FIFO)
    public Integer peek() {
        Integer result = null;
        if (tail != null) { // необходимо возвращать значение tail-a
            result = tail.value;
            tail.previous.next = null; // предыдущий эл-т станет последним   // необходимо удалить последний эл-т
            tail = tail.previous; // и тэйл меняем на превиоус
        
        }
        return result;
    } // т.о получится извлекать данные из очеред (peek) последние и добавлять в самое начало (push1)
    // идеально - работает за константную скорость и позволяет динамически расширять р--р очередеи


    // спец.вложенный класс Noda - классич.название класса для подобных структур
    public class Node {   // Node - узел
        int value;  // значение Ноды. 
        Node next;  // Так же будет ссылка на след. (односвяз.список)   // и предыд.(двунаправл.список)Ноду
        Node previous;  // поле previous, к-е будет описывать предыдущее значение для 2-связан.списка
    }
}


// основные операции для списков:
// 1. поиск эл-та
// 2. вставка ээ
// 3. удаление эл.
// 4. разворот